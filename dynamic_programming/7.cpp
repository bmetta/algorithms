/*
minimum time required to rot all oranges

You are given a matrix of dimensions m*n where each cell in the matrix can have values 0,1 or 2 which has the following meaning :

0:empty cell

1:cells have fresh oranges

2:cells have rotten oranges

So we have to determine what is the minimum time required so that all the oranges will be rotten.A rotten orange at index [i,j] can rot other fresh orange at indexes [i+1,j] ,[i,j+1] ,[i-1,j] ,[i,j-1]. If it is impossible to rot every orange then simply return -1.

NOTICE : this solution is ineffective one.
more effective solution : http://codepen.io/kaliyuga/pen/MwdMvK/?editors=001
*/

/* success case */
var matrix = [
    [2, 1, 0, 2, 1],
    [1, 0, 1, 2, 1],
    [1, 0, 0, 2, 1]
];

/* fail case */
/*
var matrix = [
    [2, 1, 0, 2, 1],
    [0, 0, 1, 2, 1],
    [1, 0, 0, 2, 1]
];
*/

var directions = [
    [1, 0],  // down
    [0, 1],  // right
    [-1, 0], // up
    [0, -1]  // left
];

var calc_rot_time = function(m) {
    
    // 1. ?? ?? ?? ??? ??. ??? ? ?? ?? ??? ? ?? ??. (time frame ?? ??? ???? ???.)
    //    ? ??? ?? ? ??? ? ?? ?? ??? ??? ??.
    //    1) 0 ?? 1 : ?? ??? ?? (? ?, ??? ???)
    //    2) 2 ?? : ?? ? ??? ???? + 2. ? ?? 2 ?? ???? 0 (???? ?? ??), ?? 5?? ???? 3 (3 ???? ?? ??)
    for (var row = 0 ; row < m.length ; row++) {
        for (var col = 0 ; col < m[0].length ; col++) {
            // ?? ???? ?? ?? ???? ?? ????? ?? ?? ?? ??
            if (m[row][col] === 2) {
                propagate_from(m, row, col);
            }
        }
    }
    
    // 2. ?? ??? ???? ?? ?? ?? ?? ?? ???. ?? ??? ??? ???? ?? ???? ?? -1 ??.
    //    * ?? ?? ??? ??? ???? ?? propagation ???? ??? ??? ? ?? ??? ??????, ?? ???? ?? ???.
    // max_time? 0?? ???? ?????, ???? 2??? 2 ??? ??? ?? ???? ???? ??? ??.
    var max_time = 2;
    for (var row = 0 ; row < m.length ; row++) {
        for (var col = 0 ; col < m[0].length ; col++) {
            if (m[row][col] === 1) {
                return -1;
            } else if (m[row][col] > max_time) {
                max_time = m[row][col];
            }
        }
    }
    // ??? ?? ??? ? ?? ??? - 2 ? ??. (0? ??? 2? ????? ?? ??????)
    return max_time - 2;
}

var propagate_from = function(m, row, col) {
    // ???? 4???? ?? ??
    for (var d_index = 0 ; d_index < directions.length ; d_index++) {
        var row_to_go = row + directions[d_index][0];
        var col_to_go = col + directions[d_index][1];
        if (row_to_go >= 0 && row_to_go < m.length && col_to_go >= 0 && col_to_go < m[0].length
            && (m[row_to_go][col_to_go] === 1 || m[row_to_go][col_to_go] > m[row][col] + 1)) {
            m[row_to_go][col_to_go] = m[row][col] + 1;
            propagate_from(m, row_to_go, col_to_go);
        }
    }
}

var test_print_matrix = function(m, desc) {
    document.write("===== " + desc + " :start =====<br>");
    for (var row = 0 ; row < m.length ; row++) {
        document.write(m[row] + "<br>");
    }
    document.write("===== " + desc + " :end =====<br>");
}

test_print_matrix(matrix, "BEFORE");

document.write("ANSWER : " + calc_rot_time(matrix) + "<br>");

test_print_matrix(matrix, "AFTER");


